<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Pipeline Designer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-dark: #0d0d0d; --canvas-bg: #0f1419; --grid-lines: #1e2a35;
            --sidebar-bg: #0a0f14; --sidebar-border: #1e2d3d;
            --accent-primary: #0ea5e9; --accent-secondary: #f97316;
            --warning: #eab308; --error: #ef4444; --text-primary: #e2e8f0; --text-secondary: #64748b;
            --node-source: #22c55e; --node-transform: #8b5cf6; --node-validate: #f59e0b;
            --node-filter: #ec4899; --node-aggregate: #06b6d4; --node-dest: #0ea5e9;
        }
        body { font-family: "DM Sans", system-ui, sans-serif; background: var(--bg-dark); color: var(--text-primary); overflow: hidden; height: 100vh; }
        .header { height: 60px; background: var(--sidebar-bg); border-bottom: 1px solid var(--sidebar-border); display: flex; align-items: center; padding: 0 20px; gap: 16px; z-index: 100; }
        .header-title { font-family: "JetBrains Mono", monospace; font-size: 18px; font-weight: 600; color: var(--accent-primary); display: flex; align-items: center; gap: 10px; }
        .header-title svg { width: 28px; height: 28px; }
        .workflow-name { flex: 1; max-width: 300px; }
        .workflow-name input { width: 100%; background: var(--canvas-bg); border: 1px solid var(--sidebar-border); border-radius: 6px; padding: 8px 12px; color: var(--text-primary); font-size: 14px; }
        .workflow-name input:focus { outline: none; border-color: var(--accent-primary); }
        .header-actions { display: flex; gap: 8px; }
        .btn { font-size: 13px; font-weight: 500; padding: 8px 16px; border-radius: 8px; border: none; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.2s; }
        .btn svg { width: 16px; height: 16px; }
        .btn-primary { background: var(--accent-primary); color: var(--bg-dark); }
        .btn-primary:hover { background: #38bdf8; }
        .btn-secondary { background: var(--canvas-bg); color: var(--text-primary); border: 1px solid var(--sidebar-border); }
        .btn-secondary:hover { border-color: var(--accent-primary); color: var(--accent-primary); }
        .btn-danger { background: transparent; color: var(--error); border: 1px solid var(--error); }
        .btn-danger:hover { background: var(--error); color: white; }
        .main-container { display: flex; height: calc(100vh - 60px); }
        .sidebar { width: 280px; background: var(--sidebar-bg); border-right: 1px solid var(--sidebar-border); overflow-y: auto; padding: 16px; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--sidebar-border); border-radius: 3px; }
        .node-category { margin-bottom: 20px; }
        .category-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; color: var(--text-secondary); margin-bottom: 12px; }
        .palette-node { background: var(--canvas-bg); border: 1px solid var(--sidebar-border); border-radius: 10px; padding: 12px; margin-bottom: 8px; cursor: grab; transition: all 0.2s; display: flex; align-items: center; gap: 12px; }
        .palette-node:hover { border-color: var(--accent-primary); transform: translateX(4px); box-shadow: 0 4px 12px rgba(14, 165, 233, 0.15); }
        .palette-node:active { cursor: grabbing; }
        .palette-node-icon { width: 36px; height: 36px; border-radius: 8px; display: flex; align-items: center; justify-content: center; }
        .palette-node-icon svg { width: 20px; height: 20px; color: white; }
        .palette-node-info { flex: 1; }
        .palette-node-title { font-size: 13px; font-weight: 600; margin-bottom: 2px; }
        .palette-node-desc { font-size: 11px; color: var(--text-secondary); }
        .canvas-container { flex: 1; position: relative; overflow: hidden; background: var(--canvas-bg); }
        .canvas { position: absolute; width: 10000px; height: 10000px; background-image: linear-gradient(var(--grid-lines) 1px, transparent 1px), linear-gradient(90deg, var(--grid-lines) 1px, transparent 1px); background-size: 24px 24px; cursor: grab; }
        .canvas.panning { cursor: grabbing; }
        .canvas-controls { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 8px; z-index: 50; }
        .canvas-controls .btn { width: 40px; height: 40px; padding: 0; justify-content: center; background: var(--sidebar-bg); border: 1px solid var(--sidebar-border); color: var(--text-primary); }
        .canvas-controls .btn:hover { border-color: var(--accent-primary); color: var(--accent-primary); }
        .zoom-level { font-family: "JetBrains Mono", monospace; font-size: 11px; color: var(--text-secondary); text-align: center; padding: 4px; }
        .canvas-node { position: absolute; min-width: 200px; background: var(--sidebar-bg); border-radius: 12px; border: 2px solid var(--sidebar-border); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4); cursor: move; user-select: none; transition: transform 0.15s; z-index: 10; }
        .canvas-node:hover { transform: scale(1.02); }
        .canvas-node.selected { border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2); }
        .canvas-node.dragging { opacity: 0.8; z-index: 100; }
        .node-header { padding: 12px 16px; border-radius: 10px 10px 0 0; display: flex; align-items: center; gap: 10px; }
        .node-header-icon { width: 28px; height: 28px; border-radius: 6px; display: flex; align-items: center; justify-content: center; }
        .node-header-icon svg { width: 16px; height: 16px; color: white; }
        .node-header-title { font-family: "JetBrains Mono", monospace; font-size: 13px; font-weight: 600; color: white; flex: 1; }
        .node-delete { width: 24px; height: 24px; border-radius: 6px; background: transparent; border: none; color: var(--text-secondary); cursor: pointer; opacity: 0; transition: all 0.2s; }
        .canvas-node:hover .node-delete { opacity: 1; }
        .node-delete:hover { background: var(--error); color: white; }
        .node-body { padding: 12px 16px; border-top: 1px solid var(--sidebar-border); display: flex; justify-content: space-between; }
        .node-ports { display: flex; flex-direction: column; gap: 8px; }
        .node-port { width: 14px; height: 14px; border-radius: 50%; background: var(--canvas-bg); border: 2px solid var(--text-secondary); cursor: crosshair; transition: all 0.2s; position: relative; }
        .node-port:hover { transform: scale(1.3); border-color: var(--accent-primary); }
        .node-port.input { position: absolute; left: -7px; top: 50%; transform: translateY(-50%); }
        .node-port.output { position: absolute; right: -7px; top: 50%; transform: translateY(-50%); }
        .node-port-label { font-size: 10px; color: var(--text-secondary); position: absolute; white-space: nowrap; }
        .node-port.input .node-port-label { left: -50px; }
        .node-port.output .node-port-label { right: -50px; }
        .connections-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .connection-line { fill: none; stroke-width: 2; pointer-events: stroke; cursor: pointer; }
        .connection-line:hover { stroke-width: 4; }
        .connection-preview { fill: none; stroke: var(--accent-primary); stroke-width: 2; stroke-dasharray: 8 4; pointer-events: none; }
        .properties-panel { width: 320px; background: var(--sidebar-bg); border-left: 1px solid var(--sidebar-border); overflow-y: auto; padding: 20px; }
        .properties-panel::-webkit-scrollbar { width: 6px; }
        .properties-panel::-webkit-scrollbar-thumb { background: var(--sidebar-border); border-radius: 3px; }
        .panel-empty { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; color: var(--text-secondary); text-align: center; }
        .panel-empty svg { width: 48px; height: 48px; margin-bottom: 16px; opacity: 0.3; }
        .panel-header { display: flex; align-items: center; gap: 12px; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--sidebar-border); }
        .panel-header-icon { width: 44px; height: 44px; border-radius: 10px; display: flex; align-items: center; justify-content: center; }
        .panel-header-icon svg { width: 24px; height: 24px; color: white; }
        .panel-header-title { font-size: 16px; font-weight: 600; }
        .panel-header-type { font-size: 12px; color: var(--text-secondary); }
        .property-group { margin-bottom: 20px; }
        .property-group-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; color: var(--text-secondary); margin-bottom: 12px; }
        .property-field { margin-bottom: 12px; }
        .property-label { display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; }
        .property-input { width: 100%; background: var(--canvas-bg); border: 1px solid var(--sidebar-border); border-radius: 6px; padding: 10px 12px; color: var(--text-primary); font-size: 13px; }
        .property-input:focus { outline: none; border-color: var(--accent-primary); }
        .property-textarea { min-height: 80px; resize: vertical; font-family: "JetBrains Mono", monospace; font-size: 12px; }
        .property-select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 12px center; padding-right: 36px; }
        @keyframes nodeAppear { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        .canvas-node { animation: nodeAppear 0.2s ease-out; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.2s; }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal { background: var(--sidebar-bg); border-radius: 16px; padding: 24px; max-width: 500px; width: 90%; transform: scale(0.9); transition: transform 0.2s; }
        .modal-overlay.active .modal { transform: scale(1); }
        .modal-title { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
        .modal-content { margin-bottom: 20px; }
        .modal-content textarea { width: 100%; min-height: 250px; background: var(--canvas-bg); border: 1px solid var(--sidebar-border); border-radius: 8px; padding: 12px; color: var(--text-primary); font-family: "JetBrains Mono", monospace; font-size: 12px; resize: vertical; }
        .modal-actions { display: flex; gap: 12px; justify-content: flex-end; }
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(100px); background: var(--sidebar-bg); border: 1px solid var(--accent-primary); border-radius: 10px; padding: 12px 20px; font-size: 13px; z-index: 1001; opacity: 0; transition: all 0.3s; }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        .context-menu { position: fixed; background: var(--sidebar-bg); border: 1px solid var(--sidebar-border); border-radius: 10px; padding: 8px 0; min-width: 160px; box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5); z-index: 500; display: none; }
        .context-menu.active { display: block; }
        .context-menu-item { padding: 10px 16px; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 10px; }
        .context-menu-item:hover { background: var(--canvas-bg); }
        .context-menu-item.danger { color: var(--error); }
        .context-menu-divider { height: 1px; background: var(--sidebar-border); margin: 8px 0; }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-title">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3v18h18"/><path d="M18.7 8l-5.1 5.2-2.8-2.7L7 14.3"/>
            </svg>
            Data Pipeline Designer
        </div>
        <div class="workflow-name">
            <input type="text" id="workflowName" value="My Pipeline">
        </div>
        <div class="header-actions">
            <button class="btn btn-secondary" id="btnNew">New</button>
            <button class="btn btn-secondary" id="btnSave">Save</button>
            <button class="btn btn-secondary" id="btnLoad">Load</button>
            <button class="btn btn-secondary" id="btnExport">Export</button>
            <button class="btn btn-secondary" id="btnImport">Import</button>
            <button class="btn btn-danger" id="btnClear">Clear</button>
        </div>
    </header>
    <div class="main-container">
        <aside class="sidebar" id="sidebar"></aside>
        <div class="canvas-container" id="canvasContainer">
            <div class="canvas" id="canvas"><svg class="connections-layer" id="connectionsLayer"></svg></div>
            <div class="canvas-controls">
                <button class="btn" id="btnZoomIn">+</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="btn" id="btnZoomOut">-</button>
                <button class="btn" id="btnFitView">Fit</button>
            </div>
        </div>
        <aside class="properties-panel" id="propertiesPanel">
            <div class="panel-empty"><p>Select a node</p></div>
        </aside>
    </div>
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal"><h3 class="modal-title" id="modalTitle">Export</h3><div class="modal-content"><textarea id="modalTextarea"></textarea></div><div class="modal-actions"><button class="btn btn-secondary" id="modalCancel">Cancel</button><button class="btn btn-primary" id="modalConfirm">Copy</button></div></div>
    </div>
    <div class="toast" id="toast"></div>
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="duplicate">Duplicate</div>
        <div class="context-menu-item" data-action="copy">Copy</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" data-action="delete">Delete</div>
    </div>
    <input type="file" id="fileInput" accept=".json" style="display: none;">
    <script>
        const NODE_TYPES = {
            // Sources
            csvSource: { category: 'sources', title: 'CSV File', description: 'Read from CSV file', color: '#22c55e', icon: 'file', inputs: [], outputs: ['data'], config: [{ name: 'path', type: 'text', label: 'File Path' }, { name: 'delimiter', type: 'text', label: 'Delimiter', default: ',' }] },
            jsonSource: { category: 'sources', title: 'JSON File', description: 'Read from JSON', color: '#22c55e', icon: 'file-json', inputs: [], outputs: ['data'], config: [{ name: 'path', type: 'text', label: 'File Path' }] },
            apiSource: { category: 'sources', title: 'API Source', description: 'Fetch from API', color: '#22c55e', icon: 'cloud', inputs: [], outputs: ['data'], config: [{ name: 'url', type: 'text', label: 'API URL' }, { name: 'method', type: 'select', label: 'Method', options: ['GET', 'POST'] }] },
            database: { category: 'sources', title: 'Database', description: 'Query database', color: '#22c55e', icon: 'database', inputs: [], outputs: ['data'], config: [{ name: 'connection', type: 'text', label: 'Connection String' }, { name: 'query', type: 'textarea', label: 'SQL Query' }] },
            // Transform
            select: { category: 'transform', title: 'Select', description: 'Select columns', color: '#8b5cf6', icon: 'columns', inputs: ['data'], outputs: ['data'], config: [{ name: 'columns', type: 'text', label: 'Columns (comma separated)' }] },
            filter: { category: 'transform', title: 'Filter', description: 'Filter rows', color: '#8b5cf6', icon: 'filter', inputs: ['data'], outputs: ['data'], config: [{ name: 'condition', type: 'text', label: 'Filter Condition' }] },
            map: { category: 'transform', title: 'Map', description: 'Transform columns', color: '#8b5cf6', icon: 'edit', inputs: ['data'], outputs: ['data'], config: [{ name: 'transforms', type: 'textarea', label: 'Transforms (JSON)', placeholder: '{"new_col": "old_col * 2"}' }] },
            join: { category: 'transform', title: 'Join', description: 'Join datasets', color: '#8b5cf6', icon: 'join', inputs: ['left', 'right'], outputs: ['data'], config: [{ name: 'type', type: 'select', label: 'Join Type', options: ['inner', 'left', 'right', 'outer'] }, { name: 'key', type: 'text', label: 'Join Key' }] },
            merge: { category: 'transform', title: 'Merge', description: 'Merge columns', color: '#8b5cf6', icon: 'merge', inputs: ['data'], outputs: ['data'], config: [{ name: 'strategy', type: 'select', label: 'Strategy', options: ['concat', 'update'] }] },
            // Validate
            validateSchema: { category: 'validate', title: 'Validate Schema', description: 'Validate data schema', color: '#f59e0b', icon: 'check-square', inputs: ['data'], outputs: ['valid', 'invalid'], config: [{ name: 'schema', type: 'textarea', label: 'Schema (JSON)', placeholder: '{"column": "type"}' }] },
            dedupe: { category: 'validate', title: 'Deduplicate', description: 'Remove duplicates', color: '#f59e0b', icon: 'copy', inputs: ['data'], outputs: ['data'], config: [{ name: 'keys', type: 'text', label: 'Dedupe Keys' }] },
            // Aggregate
            groupBy: { category: 'aggregate', title: 'Group By', description: 'Group and aggregate', color: '#06b6d4', icon: 'group', inputs: ['data'], outputs: ['data'], config: [{ name: 'groupKey', type: 'text', label: 'Group By' }, { name: 'aggregations', type: 'textarea', label: 'Aggregations', placeholder: '{"count": "COUNT(*)", "sum": "SUM(amount)"}' }] },
            sort: { category: 'aggregate', title: 'Sort', description: 'Sort data', color: '#06b6d4', icon: 'sort', inputs: ['data'], outputs: ['data'], config: [{ name: 'column', type: 'text', label: 'Sort By' }, { name: 'order', type: 'select', label: 'Order', options: ['asc', 'desc'] }] },
            // Destinations
            csvDest: { category: 'destinations', title: 'CSV Output', description: 'Write to CSV', color: '#0ea5e9', icon: 'download', inputs: ['data'], outputs: [], config: [{ name: 'path', type: 'text', label: 'Output Path' }] },
            jsonDest: { category: 'destinations', title: 'JSON Output', description: 'Write to JSON', color: '#0ea5e9', icon: 'file-json', inputs: ['data'], outputs: [], config: [{ name: 'path', type: 'text', label: 'Output Path' }] },
            apiDest: { category: 'destinations', title: 'API Output', description: 'Send to API', color: '#0ea5e9', icon: 'upload', inputs: ['data'], outputs: [], config: [{ name: 'url', type: 'text', label: 'API URL' }, { name: 'method', type: 'select', label: 'Method', options: ['POST', 'PUT'] }] }
        };
        const ICONS = {
            file: '<path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><path d="M14 2v6h6"/>',
            'file-json': '<path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><path d="M14 2v6h6M8 13h2M8 17h2M14 13h2M14 17h2"/>',
            cloud: '<path d="M18 10h-1.26A8 8 0 109 20h9a5 5 0 000-10z"/>',
            database: '<ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/>',
            columns: '<rect x="3" y="3" width="18" height="18" rx="2"/><path d="M12 3v18"/>',
            filter: '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>',
            edit: '<path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>',
            join: '<circle cx="6" cy="12" r="3"/><circle cx="18" cy="12" r="3"/><path d="M9 12h6"/>',
            merge: '<circle cx="6" cy="6" r="3"/><circle cx="18" cy="18" r="3"/><path d="M6 9v6c0 3 3 3 6 3h3"/>',
            'check-square': '<polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/>',
            copy: '<rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/>',
            group: '<path d="M16 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="8.5" cy="7" r="4"/><path d="M20 8v6M23 11h-6"/>',
            sort: '<path d="M3 6h18M6 12h12M9 18h6"/>',
            download: '<path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><path d="M7 10l5 5 5-5M12 15V3"/>',
            upload: '<path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><path d="M17 8l-5-5-5 5M12 3v12"/>'
        };
        const state = { nodes: [], connections: [], selectedNode: null, zoom: 1, panX: 0, panY: 0, isPanning: false, isConnecting: false, connectStart: null, connectEnd: null, dragOffset: { x: 0, y: 0 }, history: [], historyIndex: -1 };
        const canvas = document.getElementById('canvas'), canvasContainer = document.getElementById('canvasContainer'), connectionsLayer = document.getElementById('connectionsLayer'), sidebar = document.getElementById('sidebar'), propertiesPanel = document.getElementById('propertiesPanel'), zoomLevel = document.getElementById('zoomLevel'), modalOverlay = document.getElementById('modalOverlay'), toast = document.getElementById('toast'), contextMenu = document.getElementById('contextMenu');
        function init() { buildPalette(); setupEvents(); loadFromStorage(); render(); }
        function buildPalette() {
            const categories = { sources: { title: 'Data Sources', nodes: [] }, transform: { title: 'Transform', nodes: [] }, validate: { title: 'Validate', nodes: [] }, aggregate: { title: 'Aggregate', nodes: [] }, destinations: { title: 'Destinations', nodes: [] } };
            Object.entries(NODE_TYPES).forEach(([type, config]) => { categories[config.category].nodes.push({ type, ...config }); });
            let html = '';
            Object.entries(categories).forEach(([key, cat]) => { if (cat.nodes.length) { html += `<div class="node-category"><div class="category-title">${cat.title}</div>`; html += cat.nodes.map(n => `<div class="palette-node" draggable="true" data-type="${n.type}"><div class="palette-node-icon" style="background:${n.color}"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ICONS[n.icon]}</svg></div><div class="palette-node-info"><div class="palette-node-title">${n.title}</div><div class="palette-node-desc">${n.description}</div></div></div>`).join(''); html += '</div>'; } });
            sidebar.innerHTML = html;
            document.querySelectorAll('.palette-node').forEach(item => { item.addEventListener('dragstart', e => { draggedType = e.currentTarget.dataset.type; }); item.addEventListener('dragend', () => { draggedType = null; }); });
        }
        let draggedType = null;
        function setupEvents() {
            canvasContainer.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
            canvasContainer.addEventListener('drop', e => { e.preventDefault(); if (draggedType) { const rect = canvas.getBoundingClientRect(); const x = (e.clientX - rect.left - state.panX) / state.zoom; const y = (e.clientY - rect.top - state.panY) / state.zoom; addNode(draggedType, x, y); } });
            canvas.addEventListener('mousedown', e => { if (e.target === canvas || e.target === connectionsLayer) { if (e.button === 1 || (e.button === 0 && e.shiftKey)) { state.isPanning = true; canvas.classList.add('panning'); state.panStart = { x: e.clientX - state.panX, y: e.clientY - state.panY }; } else selectNode(null); } });
            document.addEventListener('mousemove', e => { if (state.isPanning) { state.panX = e.clientX - state.panStart.x; state.panY = e.clientY - state.panStart.y; updateTransform(); } if (state.isConnecting && state.connectStart) { state.connectEnd = { x: (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.zoom, y: (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.zoom }; renderConnections(); } });
            document.addEventListener('mouseup', e => { if (state.isPanning) { state.isPanning = false; canvas.classList.remove('panning'); } if (state.isConnecting) { const port = e.target.closest('.node-port'); if (port && state.connectStart) { const nodeId = port.closest('.canvas-node')?.dataset.id; if (nodeId && nodeId !== state.connectStart.nodeId) { const pt = port.classList.contains('input') ? 'input' : 'output'; const pn = port.dataset.port; if (state.connectStart.type === 'output' && pt === 'input') addConnection(state.connectStart.nodeId, state.connectStart.portName, nodeId, pn); else if (state.connectStart.type === 'input' && pt === 'output') addConnection(nodeId, pn, state.connectStart.nodeId, state.connectStart.portName); } } state.isConnecting = false; state.connectStart = null; renderConnections(); } });
            canvasContainer.addEventListener('wheel', e => { e.preventDefault(); const dz = e.deltaY > 0 ? -0.1 : 0.1; const nz = Math.max(0.25, Math.min(2, state.zoom + dz)); const r = canvasContainer.getBoundingClientRect(); const mx = e.clientX - r.left, my = e.clientY - r.top; const zr = nz / state.zoom; state.panX = mx - (mx - state.panX) * zr; state.panY = my - (my - state.panY) * zr; state.zoom = nz; updateTransform(); });
            document.addEventListener('keydown', e => { if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return; if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedNode) deleteNode(state.selectedNode); if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); } });
            canvasContainer.addEventListener('contextmenu', e => { e.preventDefault(); const node = e.target.closest('.canvas-node'); if (node) { selectNode(node.dataset.id); showContextMenu(e.clientX, e.clientY); } });
            document.addEventListener('click', () => contextMenu.classList.remove('active'));
            contextMenu.addEventListener('click', e => { const action = e.target.closest('.context-menu-item')?.dataset.action; if (action && state.selectedNode) { if (action === 'duplicate') duplicateNode(state.selectedNode); else if (action === 'copy') copyNode(state.selectedNode); else if (action === 'delete') deleteNode(state.selectedNode); } });
            document.getElementById('btnNew').onclick = () => { if (confirm('New pipeline?')) { state.nodes = []; state.connections = []; state.selectedNode = null; saveHistory(); render(); } };
            document.getElementById('btnSave').onclick = () => { localStorage.setItem('pipeline-data', JSON.stringify({ name: document.getElementById('workflowName').value, nodes: state.nodes, connections: state.connections })); showToast('Saved!'); };
            document.getElementById('btnLoad').onclick = () => { const data = localStorage.getItem('pipeline-data'); if (data) { const w = JSON.parse(data); state.nodes = w.nodes || []; state.connections = w.connections || []; if (w.name) document.getElementById('workflowName').value = w.name; render(); showToast('Loaded!'); } };
            document.getElementById('btnExport').onclick = () => { document.getElementById('modalTitle').textContent = 'Export Pipeline'; document.getElementById('modalTextarea').value = JSON.stringify({ name: document.getElementById('workflowName').value, nodes: state.nodes, connections: state.connections }, null, 2); document.getElementById('modalTextarea').readOnly = true; document.getElementById('modalConfirm').onclick = () => { navigator.clipboard.writeText(document.getElementById('modalTextarea').value); showToast('Copied!'); closeModal(); }; modalOverlay.classList.add('active'); };
            document.getElementById('btnImport').onclick = () => document.getElementById('fileInput').click();
            document.getElementById('fileInput').onchange = e => { const f = e.target.files[0]; if (f) { const r = new FileReader(); r.onload = ev => { try { const w = JSON.parse(ev.target.result); state.nodes = w.nodes || []; state.connections = w.connections || []; if (w.name) document.getElementById('workflowName').value = w.name; saveHistory(); render(); showToast('Imported!'); } catch (err) { showToast('Invalid JSON'); } }; r.readAsText(f); e.target.value = ''; } };
            document.getElementById('btnClear').onclick = () => { if (confirm('Clear?')) { state.nodes = []; state.connections = []; state.selectedNode = null; saveHistory(); render(); showToast('Cleared'); } };
            document.getElementById('btnZoomIn').onclick = () => { state.zoom = Math.min(2, state.zoom + 0.1); updateTransform(); };
            document.getElementById('btnZoomOut').onclick = () => { state.zoom = Math.max(0.25, state.zoom - 0.1); updateTransform(); };
            document.getElementById('btnFitView').onclick = fitView;
            document.getElementById('modalCancel').onclick = closeModal;
            modalOverlay.onclick = e => { if (e.target === modalOverlay) closeModal(); };
        }
        function updateTransform() { canvas.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`; zoomLevel.textContent = Math.round(state.zoom * 100) + '%'; renderConnections(); }
        function addNode(type, x, y) { const nt = NODE_TYPES[type]; const node = { id: genId(), type, x: x - 100, y: y - 40, config: {} }; nt.config.forEach(f => { if (f.default !== undefined) node.config[f.name] = f.default; }); state.nodes.push(node); saveHistory(); render(); selectNode(node.id); showToast('Added ' + nt.title); }
        function deleteNode(id) { state.nodes = state.nodes.filter(n => n.id !== id); state.connections = state.connections.filter(c => c.source !== id && c.target !== id); if (state.selectedNode === id) state.selectedNode = null; saveHistory(); render(); showToast('Deleted'); }
        function duplicateNode(id) { const n = state.nodes.find(x => x.id === id); if (n) { const nn = { ...JSON.parse(JSON.stringify(n)), id: genId(), x: n.x + 30, y: n.y + 30 }; state.nodes.push(nn); saveHistory(); render(); selectNode(nn.id); showToast('Duplicated'); } }
        function copyNode(id) { const n = state.nodes.find(x => x.id === id); if (n) { navigator.clipboard.writeText(JSON.stringify(n, null, 2)); showToast('Copied!'); } }
        function addConnection(sid, sport, tid, tport) { if (state.connections.some(c => c.source === sid && c.target === tid) || sid === tid) return; state.connections = state.connections.filter(c => c.target !== tid || c.targetPort !== tport); state.connections.push({ id: genId(), source: sid, sourcePort: sport, target: tid, targetPort: tport }); saveHistory(); render(); }
        function deleteConnection(id) { state.connections = state.connections.filter(c => c.id !== id); render(); }
        function selectNode(id) { state.selectedNode = id; render(); updatePanel(); }
        function updatePanel() {
            if (!state.selectedNode) { propertiesPanel.innerHTML = '<div class="panel-empty"><p>Select a node</p></div>'; return; }
            const n = state.nodes.find(x => x.id === state.selectedNode); if (!n) return;
            const nt = NODE_TYPES[n.type];
            let html = `<div class="panel-header"><div class="panel-header-icon" style="background:${nt.color}"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ICONS[nt.icon]}</svg></div><div><div class="panel-header-title">${nt.title}</div><div class="panel-header-type">${nt.description}</div></div></div>`;
            html += `<div class="property-group"><div class="property-field"><label class="property-label">Node Name</label><input type="text" class="property-input" id="propName" value="${n.config.name || ''}"></div></div>`;
            if (nt.config.length) { html += '<div class="property-group"><div class="property-group-title">Configuration</div>'; nt.config.forEach(f => { const v = n.config[f.name] !== undefined ? n.config[f.name] : (f.default || ''); html += `<div class="property-field"><label class="property-label">${f.label}</label>`; if (f.type === 'select') { html += `<select class="property-input property-select" data-field="${f.name}">`; f.options.forEach(o => { html += `<option value="${o}" ${o == v ? 'selected' : ''}>${o}</option>`; }); html += '</select>'; } else if (f.type === 'textarea') { html += `<textarea class="property-input property-textarea" data-field="${f.name}" placeholder="${f.placeholder || ''}">${v}</textarea>`; } else { html += `<input type="text" class="property-input" data-field="${f.name}" value="${v}" placeholder="${f.placeholder || ''}">`; } html += '</div>'; }); html += '</div>'; }
            propertiesPanel.innerHTML = html;
            propertiesPanel.querySelectorAll('.property-input').forEach(inp => { inp.onchange = e => { const f = e.target.dataset.field; let v = e.target.value; if (e.target.type === 'number') v = parseFloat(v); n.config[f] = v; saveHistory(); }; }); }
        function showContextMenu(x, y) { contextMenu.style.left = x + 'px'; contextMenu.style.top = y + 'px'; contextMenu.classList.add('active'); }
        function fitView() { if (!state.nodes.length) return; const b = state.nodes.reduce((a, n) => ({ minX: Math.min(a.minX, n.x), minY: Math.min(a.minY, n.y), maxX: Math.max(a.maxX, n.x + 200), maxY: Math.max(a.maxY, n.y + 80) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }); const r = canvasContainer.getBoundingClientRect(); const p = 50, sx = (r.width - p * 2) / (b.maxX - b.minX), sy = (r.height - p * 2) / (b.maxY - b.minY); state.zoom = Math.min(Math.max(Math.min(sx, sy), 0.25), 1.5); state.panX = (r.width - (b.maxX - b.minX) * state.zoom) / 2 - b.minX * state.zoom; state.panY = (r.height - (b.maxY - b.minY) * state.zoom) / 2 - b.minY * state.zoom; updateTransform(); }
        function closeModal() { modalOverlay.classList.remove('active'); }
        function saveHistory() { const s = JSON.stringify({ nodes: state.nodes, connections: state.connections }); state.history = state.history.slice(0, state.historyIndex + 1); state.history.push(s); state.historyIndex = state.history.length - 1; if (state.history.length > 50) { state.history.shift(); state.historyIndex--; } }
        function undo() { if (state.historyIndex > 0) { state.historyIndex--; const s = JSON.parse(state.history[state.historyIndex]); state.nodes = s.nodes; state.connections = s.connections; render(); } }
        function redo() { if (state.historyIndex < state.history.length - 1) { state.historyIndex++; const s = JSON.parse(state.history[state.historyIndex]); state.nodes = s.nodes; state.connections = s.connections; render(); } }
        function showToast(m) { toast.textContent = m; toast.classList.add('show'); setTimeout(() => toast.classList.remove('show'), 3000); }
        function genId() { return 'n_' + Math.random().toString(36).substr(2, 9); }
        function render() { renderNodes(); renderConnections(); updatePanel(); }
        function renderNodes() { canvas.querySelectorAll('.canvas-node').forEach(el => el.remove()); state.nodes.forEach(n => { const nt = NODE_TYPES[n.type]; const el = document.createElement('div'); el.className = `canvas-node ${state.selectedNode === n.id ? 'selected' : ''}`; el.dataset.id = n.id; el.style.left = n.x + 'px'; el.style.top = n.y + 'px'; let inh = '', outh = ''; nt.inputs.forEach(i => { inh += `<div class="node-port input" data-port="${i}"><span class="node-port-label">${i}</span></div>`; }); nt.outputs.forEach(o => { outh += `<div class="node-port output" data-port="${o}"><span class="node-port-label">${o}</span></div>`; }); el.innerHTML = `<div class="node-header" style="background:${nt.color}"><div class="node-header-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ICONS[nt.icon]}</svg></div><div class="node-header-title">${nt.title}</div><button class="node-delete">Ã—</button></div><div class="node-body"><div class="node-ports">${inh}</div><div class="node-ports">${outh}</div></div>`; el.onmousedown = e => { if (e.target.closest('.node-port') || e.target.closest('.node-delete')) return; e.stopPropagation(); selectNode(n.id); state.isDragging = true; el.classList.add('dragging'); const ro = el.getBoundingClientRect(); state.dragOffset = { x: e.clientX - ro.left, y: e.clientY - ro.top }; const hm = e => { if (!state.isDragging) return; const cr = canvas.getBoundingClientRect(); n.x = (e.clientX - cr.left - state.panX) / state.zoom - state.dragOffset.x; n.y = (e.clientY - cr.top - state.panY) / state.zoom - state.dragOffset.y; el.style.left = n.x + 'px'; el.style.top = n.y + 'px'; renderConnections(); }; const hu = () => { state.isDragging = false; el.classList.remove('dragging'); saveHistory(); document.removeEventListener('mousemove', hm); document.removeEventListener('mouseup', hu); }; document.addEventListener('mousemove', hm); document.addEventListener('mouseup', hu); }; el.querySelectorAll('.node-port').forEach(p => { p.onmousedown = e => { e.stopPropagation(); const pt = p.classList.contains('input') ? 'input' : 'output'; state.isConnecting = true; state.connectStart = { nodeId: n.id, portName: p.dataset.port, type: pt, x: n.x + (pt === 'output' ? 200 : 0), y: n.y + 56 }; state.connectEnd = { ...state.connectStart }; }; }); el.querySelector('.node-delete').onclick = e => { e.stopPropagation(); deleteNode(n.id); }; canvas.appendChild(el); }); }
        function renderConnections() { connectionsLayer.innerHTML = ''; connectionsLayer.setAttribute('viewBox', '0 0 10000 10000'); connectionsLayer.setAttribute('width', '10000'); connectionsLayer.setAttribute('height', '10000'); state.connections.forEach(c => { const sn = state.nodes.find(n => n.id === c.source), tn = state.nodes.find(n => n.id === c.target); if (!sn || !tn) return; const st = NODE_TYPES[sn.type]; const si = st.outputs.indexOf(c.sourcePort); const by = sn.y + 56; const yo = st.outputs.length > 1 ? (si - (st.outputs.length - 1) / 2) * 20 : 0; const x1 = sn.x + 200, y1 = by + yo, x2 = tn.x, y2 = by + yo; const cpo = Math.min(100, Math.abs(x2 - x1) / 2); const path = `M ${x1} ${y1} C ${x1 + cpo} ${y1}, ${x2 - cpo} ${y2}, ${x2} ${y2}`; const pel = document.createElementNS('http://www.w3.org/2000/svg', 'path'); pel.setAttribute('d', path); pel.setAttribute('class', 'connection-line'); pel.setAttribute('stroke', st.color); pel.onclick = e => { e.stopPropagation(); deleteConnection(c.id); }; connectionsLayer.appendChild(pel); }); if (state.isConnecting && state.connectStart && state.connectEnd) { const sx = state.connectStart.type === 'output' ? state.connectStart.x : state.connectEnd.x; const sy = state.connectStart.type === 'output' ? state.connectStart.y : state.connectEnd.y; const ex = state.connectStart.type === 'output' ? state.connectEnd.x : state.connectStart.x; const ey = state.connectStart.type === 'output' ? state.connectEnd.y : state.connectStart.y; const cpo = Math.min(100, Math.abs(ex - sx) / 2); const path = `M ${sx} ${sy} C ${sx + cpo} ${sy}, ${ex - cpo} ${ey}, ${ex} ${ey}`; const pel = document.createElementNS('http://www.w3.org/2000/svg', 'path'); pel.setAttribute('d', path); pel.setAttribute('class', 'connection-preview'); connectionsLayer.appendChild(pel); } }
        init();
    </script>
</body>
</html>
